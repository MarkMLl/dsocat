
(* This file contains the list of procedures/functions exported by the backend  *)
(* shared library, which also doubles as the list of methods implemented by the *)
(* TBackend shim class in the frontend main program.                            *)
(*                                                                              *)
(* It is used in both the frontend and backend projects, and is located in the  *)
(* common directory.                                            MarkMLl.        *)

{$ifdef BACKEND_MAGIC_NUMBER  }
const
  BackendMagicNumber= 1908201719;

{$endif BACKEND_MAGIC_NUMBER  }
{$ifdef BACKEND_ENTRY_POINTS  }

(* Return a 32-bit unsigned magic number, this does not require any action from
  the memory manager. Despite being generated by backend code, this should be
  changed to track the functions and parameters described by backendprocs.inc,
  which is to be considered definitive.
*)
function SharedLibraryMagicNumber(): longword;

(* This is called by the frontend, but implemented by the backend. Tell the
  backend to do whatever's necessary to get access to entry points exported by
  the frontend, at least up to the point where it checks that magic numbers
  match. Return the frontend's magic number if this is OK, except that zero is
  reserved to indicate that a formatted error message is available via the
  SharedLibraryBindMainProgramError function.
*)
function SharedLibraryBindMainProgramExports: longword;

(* Read and clear any error message from BackendBindFrontendExports.
*)
function SharedLibraryBindMainProgramError: string;

(* This is normally called automatically when the backend is loaded, but may
  also be invoked on e.g. receipt of a HUP.
*)
function LoadConfiguration(base: string= ''): boolean;

(* Return a string containing the library's "About" text, hopefully including
  build date and time and Subversion release.

  This is actually a pointer into the library's heap, so it is essential that
  this is shared with the main program- typically by use of the cmem library.
*)
function BackendAboutText: string;

(* Return an object containing a TMenuItem, possibly with children.

  This is actually a pointer into the library's heap, so it is essential that
  this is shared with the main program- typically by use of the cmem library.
*)
function BackendMenuFile: TMenuItem;

(* Return an object containing a TMenuItem, possibly with children; it is the
  caller's responsibility to free this.

  This is actually a pointer into the library's heap, so it is essential that
  this is shared with the main program- typically by use of the cmem library.
*)
function BackendMenuConfig: TMenuItem;

(* Return an object containing a TMenuItem, possibly with children; it is the
  caller's responsibility to free this.

  This is actually a pointer into the library's heap, so it is essential that
  this is shared with the main program- typically by use of the cmem library.
*)
function BackendMenuHelp: TMenuItem;

(* This is the magic number from backendprocs.inc at the time the frontend was
  built, it should match the one returned by the backend shared library.
*)
// TODO : function FrontendMagicNumber: longword;

(* Return a pattern for the type of port the device is expected to be connected
  to, e.g. ttyUSB for most USB-connected serial ports. Return blank to test
  every port.
*)
function PortName(): string;

(* Return the expected driver (kernel module) name, as found in the /sys tree.
  Return blank for no tests.
*)
function PortDriverName(): string;

(* Return the device product description, as found in the /sys tree. Return
  blank for no tests.
*)
function PortProductDescription(): string;

(* Return the device serial number, as found in the /sys tree. Note that this
  is a text string of undefined format i.e. cannot be assumed to be numeric or
  even a number expressed in some customary base, return blank for no tests.
*)
function PortSerialDescription(): string;

(* Return the parameters to be used by default when setting up the serial port.
  If this returns true then assume that using these are mandatory since the
  instrument has no accessible controls for Baud rate etc.
*)
function PortDefaultParams(out BitsPerSec: LongInt; out ByteSize: Integer;
                                        out Parity: TParityType; out StopBits: Integer;
                                        out Flags: TSerialFlags): boolean;

(* Parse and delete the parameter, returning an object representing the
  instrument state or nil on error.
*)
function ParseRawToScopeStruct(raw: TStringList): TScopeStruct;

(* Generate test data, adhering as closely as possible to the behaviour of
  ParseRawToScopeStruct() above.
*)
function ParseTestToScopeStruct(testType: TTestType): TScopeStruct;

{$endif BACKEND_ENTRY_POINTS  }
{$ifdef BACKEND_POSTLOAD_PROC }


(* After the successful completion of BackendLoad, perform any application-
  specific initialisation. This used to be in BackendLoad but was moved out to
  allow checks for magic numbers etc. to be completed, the corresponding
  termination code has been left in backendUnload.
*)
procedure BackendPostLoad(projectName: string; lastButton: integer= -1);

var     i: integer;


  function deepCopyOf(mi: TMenuItem): TMenuItem;

  var   i: integer;

  begin
    if mi = nil then begin
      result := nil;
      exit
    end;
    result := TMenuItem.Create(Application.MainForm);
    with result do begin
//      Action := mi.Action;
      AutoCheck := mi.AutoCheck;
//      Bitmap := mi.Bitmap;
      Caption := mi.Caption;
      Checked := mi.Checked;
      Default := mi.Default;
      Enabled := mi.Enabled;
//      GlyphShowMode := mi.GlyphShowMode;
      GroupIndex := mi.GroupIndex;
      HelpContext := mi.HelpContext;
      Hint := mi.Hint;
//      ImageIndex := mi.ImageIndex;
      Name := mi.Name;
      RadioItem := mi.RadioItem;
      RightJustify := RightJustify;
      ShortCut := mi.ShortCut;
      ShortCutKey2 := mi.ShortCutKey2;
      ShowAlwaysCheckable := mi.ShowAlwaysCheckable;
//      SubMenuImages := mi.SubMenuImages;
{$ifdef USE_DYNAMIC }
      Tag := PtrInt(Backend);           (* Using PtrUInt here would be better   *)
{$endif USE_DYNAMIC }
      Visible := mi.Visible;
      for i := 0 to mi.Count - 1 do
        Add(deepCopyOf(mi.Items[i]));
      OnClick := mi.OnClick
    end
  end { deepCopyOf } ;


begin

(* This is invoked in the context of the frontend form, so can refer directly   *)
(* to it in order to force the GUI to a consistent state.                       *)

// Insert GUI stuff here ad lib.

  Backend.LoadConfiguration(projectName);

(* For each standard main menu item, add the items from the backend tagging     *)
(* each so that we can subsequently delete them. TMenuItem doesn't have working *)
(* Assign() or AssignTo methods, and we can't do Add(TMenuItem(Tag).Items[i])   *)
(* since there's an internal check for whether the item being added already has *)
(* a parent... I'd rather not mess with trying to change parentage on-the-fly.  *)

  with FormDsoCat.MenuItemFile do begin
    for i := 0 to Backend.BackendMenuFile.Count - 1 do
      Add(deepCopyOf(Backend.BackendMenuFile.Items[i]));
    Tag := Ord(Enabled);
    Enabled := Enabled or Backend.BackendMenuFile.Enabled
  end;

  with FormDsoCat.MenuItemConfig do begin
    for i := 0 to Backend.BackendMenuConfig.Count - 1 do
      Add(deepCopyOf(Backend.BackendMenuConfig.Items[i]));
    Tag := Ord(Enabled);
    Enabled := Enabled or Backend.BackendMenuConfig.Enabled
  end;

  with FormDsoCat.MenuItemHelp do begin
    for i := 0 to Backend.BackendMenuHelp.Count - 1 do
      Add(deepCopyOf(Backend.BackendMenuHelp.Items[i]));
    Tag := Ord(Enabled);
    Enabled := Enabled or Backend.BackendMenuHelp.Enabled
  end
end { BackendPostLoad } ;

{$endif BACKEND_POSTLOAD_PROC }

